// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ryutah/realworld-echo/realworld-api/usecase (interfaces: GetArticleOutputPort,ErrorOutputPort,ErrorHandler,ErrorReporter)

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	xerrorreport "github.com/ryutah/realworld-echo/realworld-api/pkg/xerrorreport"
	usecase "github.com/ryutah/realworld-echo/realworld-api/usecase"
)

// MockGetArticleOutputPort is a mock of GetArticleOutputPort interface.
type MockGetArticleOutputPort struct {
	ctrl     *gomock.Controller
	recorder *MockGetArticleOutputPortMockRecorder
}

// MockGetArticleOutputPortMockRecorder is the mock recorder for MockGetArticleOutputPort.
type MockGetArticleOutputPortMockRecorder struct {
	mock *MockGetArticleOutputPort
}

// NewMockGetArticleOutputPort creates a new mock instance.
func NewMockGetArticleOutputPort(ctrl *gomock.Controller) *MockGetArticleOutputPort {
	mock := &MockGetArticleOutputPort{ctrl: ctrl}
	mock.recorder = &MockGetArticleOutputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetArticleOutputPort) EXPECT() *MockGetArticleOutputPortMockRecorder {
	return m.recorder
}

// Success mocks base method.
func (m *MockGetArticleOutputPort) Success(arg0 context.Context, arg1 usecase.GetArticleResult) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Success", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Success indicates an expected call of Success.
func (mr *MockGetArticleOutputPortMockRecorder) Success(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Success", reflect.TypeOf((*MockGetArticleOutputPort)(nil).Success), arg0, arg1)
}

// MockErrorOutputPort is a mock of ErrorOutputPort interface.
type MockErrorOutputPort struct {
	ctrl     *gomock.Controller
	recorder *MockErrorOutputPortMockRecorder
}

// MockErrorOutputPortMockRecorder is the mock recorder for MockErrorOutputPort.
type MockErrorOutputPortMockRecorder struct {
	mock *MockErrorOutputPort
}

// NewMockErrorOutputPort creates a new mock instance.
func NewMockErrorOutputPort(ctrl *gomock.Controller) *MockErrorOutputPort {
	mock := &MockErrorOutputPort{ctrl: ctrl}
	mock.recorder = &MockErrorOutputPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockErrorOutputPort) EXPECT() *MockErrorOutputPortMockRecorder {
	return m.recorder
}

// BadRequest mocks base method.
func (m *MockErrorOutputPort) BadRequest(arg0 context.Context, arg1 usecase.ErrorResult) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BadRequest", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// BadRequest indicates an expected call of BadRequest.
func (mr *MockErrorOutputPortMockRecorder) BadRequest(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BadRequest", reflect.TypeOf((*MockErrorOutputPort)(nil).BadRequest), arg0, arg1)
}

// InternalError mocks base method.
func (m *MockErrorOutputPort) InternalError(arg0 context.Context, arg1 usecase.ErrorResult) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InternalError", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// InternalError indicates an expected call of InternalError.
func (mr *MockErrorOutputPortMockRecorder) InternalError(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InternalError", reflect.TypeOf((*MockErrorOutputPort)(nil).InternalError), arg0, arg1)
}

// NotFound mocks base method.
func (m *MockErrorOutputPort) NotFound(arg0 context.Context, arg1 usecase.ErrorResult) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NotFound", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// NotFound indicates an expected call of NotFound.
func (mr *MockErrorOutputPortMockRecorder) NotFound(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotFound", reflect.TypeOf((*MockErrorOutputPort)(nil).NotFound), arg0, arg1)
}

// MockErrorHandler is a mock of ErrorHandler interface.
type MockErrorHandler struct {
	ctrl     *gomock.Controller
	recorder *MockErrorHandlerMockRecorder
}

// MockErrorHandlerMockRecorder is the mock recorder for MockErrorHandler.
type MockErrorHandlerMockRecorder struct {
	mock *MockErrorHandler
}

// NewMockErrorHandler creates a new mock instance.
func NewMockErrorHandler(ctrl *gomock.Controller) *MockErrorHandler {
	mock := &MockErrorHandler{ctrl: ctrl}
	mock.recorder = &MockErrorHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockErrorHandler) EXPECT() *MockErrorHandlerMockRecorder {
	return m.recorder
}

// handle mocks base method.
func (m *MockErrorHandler) handle(arg0 context.Context, arg1 error, arg2 ...usecase.ErrorHandlerOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "handle", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// handle indicates an expected call of handle.
func (mr *MockErrorHandlerMockRecorder) handle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "handle", reflect.TypeOf((*MockErrorHandler)(nil).handle), varargs...)
}

// MockErrorReporter is a mock of ErrorReporter interface.
type MockErrorReporter struct {
	ctrl     *gomock.Controller
	recorder *MockErrorReporterMockRecorder
}

// MockErrorReporterMockRecorder is the mock recorder for MockErrorReporter.
type MockErrorReporterMockRecorder struct {
	mock *MockErrorReporter
}

// NewMockErrorReporter creates a new mock instance.
func NewMockErrorReporter(ctrl *gomock.Controller) *MockErrorReporter {
	mock := &MockErrorReporter{ctrl: ctrl}
	mock.recorder = &MockErrorReporterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockErrorReporter) EXPECT() *MockErrorReporterMockRecorder {
	return m.recorder
}

// Report mocks base method.
func (m *MockErrorReporter) Report(arg0 context.Context, arg1 error, arg2 xerrorreport.ErrorContext) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Report", arg0, arg1, arg2)
}

// Report indicates an expected call of Report.
func (mr *MockErrorReporterMockRecorder) Report(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Report", reflect.TypeOf((*MockErrorReporter)(nil).Report), arg0, arg1, arg2)
}
