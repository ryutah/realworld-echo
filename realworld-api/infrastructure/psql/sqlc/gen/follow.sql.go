// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: follow.sql

package gen

import (
	"context"
)

const ExistsFollow = `-- name: ExistsFollow :one
select
    exists (
        select
            user_id, follwer_id, created_at, updated_at
        from
            follow
        where
            user_id = $1
            and follwer_id = $2
    )
`

type ExistsFollowParams struct {
	UserID    string `db:"user_id"`
	FollwerID string `db:"follwer_id"`
}

func (q *Queries) ExistsFollow(ctx context.Context, arg ExistsFollowParams) (bool, error) {
	row := q.db.QueryRow(ctx, ExistsFollow, arg.UserID, arg.FollwerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const ExistsListFollow = `-- name: ExistsListFollow :many
with
    follow_exists as (
        select
            user_id,
            follwer_id,
            true as existance
        from
            follow
        where
            user_id = any ($2::text[])
            and follwer_id = $1
    )
select
    follow.user_id,
    follow.follwer_id,
    coalesce(follow_exists.existance, false) as existance
from
    follow
    left join follow_exists using (user_id, follwer_id)
where
    follow.user_id = any ($2::text[])
    and follow.follwer_id = $1
`

type ExistsListFollowParams struct {
	FollwerID string   `db:"follwer_id"`
	UserID    []string `db:"user_id"`
}

type ExistsListFollowRow struct {
	UserID    string `db:"user_id"`
	FollwerID string `db:"follwer_id"`
	Existance bool   `db:"existance"`
}

func (q *Queries) ExistsListFollow(ctx context.Context, arg ExistsListFollowParams) ([]ExistsListFollowRow, error) {
	rows, err := q.db.Query(ctx, ExistsListFollow, arg.FollwerID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExistsListFollowRow
	for rows.Next() {
		var i ExistsListFollowRow
		if err := rows.Scan(&i.UserID, &i.FollwerID, &i.Existance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
