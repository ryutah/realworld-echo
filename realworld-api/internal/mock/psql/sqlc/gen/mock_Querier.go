// Code generated by mockery v2.32.0. DO NOT EDIT.

package gen

import (
	context "context"

	gen "github.com/ryutah/realworld-echo/realworld-api/infrastructure/psql/sqlc/gen"
	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// MockQuerier is an autogenerated mock type for the Querier type
type MockQuerier struct {
	mock.Mock
}

type MockQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQuerier) EXPECT() *MockQuerier_Expecter {
	return &MockQuerier_Expecter{mock: &_m.Mock}
}

// CreateArticleTag provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) CreateArticleTag(ctx context.Context, arg []gen.CreateArticleTagParams) (int64, error) {
	ret := _m.Called(ctx, arg)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []gen.CreateArticleTagParams) (int64, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []gen.CreateArticleTagParams) int64); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []gen.CreateArticleTagParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateArticleTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateArticleTag'
type MockQuerier_CreateArticleTag_Call struct {
	*mock.Call
}

// CreateArticleTag is a helper method to define mock.On call
//   - ctx context.Context
//   - arg []gen.CreateArticleTagParams
func (_e *MockQuerier_Expecter) CreateArticleTag(ctx interface{}, arg interface{}) *MockQuerier_CreateArticleTag_Call {
	return &MockQuerier_CreateArticleTag_Call{Call: _e.mock.On("CreateArticleTag", ctx, arg)}
}

func (_c *MockQuerier_CreateArticleTag_Call) Run(run func(ctx context.Context, arg []gen.CreateArticleTagParams)) *MockQuerier_CreateArticleTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]gen.CreateArticleTagParams))
	})
	return _c
}

func (_c *MockQuerier_CreateArticleTag_Call) Return(_a0 int64, _a1 error) *MockQuerier_CreateArticleTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateArticleTag_Call) RunAndReturn(run func(context.Context, []gen.CreateArticleTagParams) (int64, error)) *MockQuerier_CreateArticleTag_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrDoNothingTag provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) CreateOrDoNothingTag(ctx context.Context, arg gen.CreateOrDoNothingTagParams) error {
	ret := _m.Called(ctx, arg)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.CreateOrDoNothingTagParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_CreateOrDoNothingTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrDoNothingTag'
type MockQuerier_CreateOrDoNothingTag_Call struct {
	*mock.Call
}

// CreateOrDoNothingTag is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.CreateOrDoNothingTagParams
func (_e *MockQuerier_Expecter) CreateOrDoNothingTag(ctx interface{}, arg interface{}) *MockQuerier_CreateOrDoNothingTag_Call {
	return &MockQuerier_CreateOrDoNothingTag_Call{Call: _e.mock.On("CreateOrDoNothingTag", ctx, arg)}
}

func (_c *MockQuerier_CreateOrDoNothingTag_Call) Run(run func(ctx context.Context, arg gen.CreateOrDoNothingTagParams)) *MockQuerier_CreateOrDoNothingTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.CreateOrDoNothingTagParams))
	})
	return _c
}

func (_c *MockQuerier_CreateOrDoNothingTag_Call) Return(_a0 error) *MockQuerier_CreateOrDoNothingTag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_CreateOrDoNothingTag_Call) RunAndReturn(run func(context.Context, gen.CreateOrDoNothingTagParams) error) *MockQuerier_CreateOrDoNothingTag_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteArticleTagBySlug provides a mock function with given fields: ctx, articleSlug
func (_m *MockQuerier) DeleteArticleTagBySlug(ctx context.Context, articleSlug uuid.UUID) error {
	ret := _m.Called(ctx, articleSlug)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, articleSlug)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_DeleteArticleTagBySlug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteArticleTagBySlug'
type MockQuerier_DeleteArticleTagBySlug_Call struct {
	*mock.Call
}

// DeleteArticleTagBySlug is a helper method to define mock.On call
//   - ctx context.Context
//   - articleSlug uuid.UUID
func (_e *MockQuerier_Expecter) DeleteArticleTagBySlug(ctx interface{}, articleSlug interface{}) *MockQuerier_DeleteArticleTagBySlug_Call {
	return &MockQuerier_DeleteArticleTagBySlug_Call{Call: _e.mock.On("DeleteArticleTagBySlug", ctx, articleSlug)}
}

func (_c *MockQuerier_DeleteArticleTagBySlug_Call) Run(run func(ctx context.Context, articleSlug uuid.UUID)) *MockQuerier_DeleteArticleTagBySlug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockQuerier_DeleteArticleTagBySlug_Call) Return(_a0 error) *MockQuerier_DeleteArticleTagBySlug_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_DeleteArticleTagBySlug_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockQuerier_DeleteArticleTagBySlug_Call {
	_c.Call.Return(run)
	return _c
}

// GetArticle provides a mock function with given fields: ctx, slug
func (_m *MockQuerier) GetArticle(ctx context.Context, slug uuid.UUID) (gen.Article, error) {
	ret := _m.Called(ctx, slug)

	var r0 gen.Article
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (gen.Article, error)); ok {
		return rf(ctx, slug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) gen.Article); ok {
		r0 = rf(ctx, slug)
	} else {
		r0 = ret.Get(0).(gen.Article)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, slug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetArticle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetArticle'
type MockQuerier_GetArticle_Call struct {
	*mock.Call
}

// GetArticle is a helper method to define mock.On call
//   - ctx context.Context
//   - slug uuid.UUID
func (_e *MockQuerier_Expecter) GetArticle(ctx interface{}, slug interface{}) *MockQuerier_GetArticle_Call {
	return &MockQuerier_GetArticle_Call{Call: _e.mock.On("GetArticle", ctx, slug)}
}

func (_c *MockQuerier_GetArticle_Call) Run(run func(ctx context.Context, slug uuid.UUID)) *MockQuerier_GetArticle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetArticle_Call) Return(_a0 gen.Article, _a1 error) *MockQuerier_GetArticle_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetArticle_Call) RunAndReturn(run func(context.Context, uuid.UUID) (gen.Article, error)) *MockQuerier_GetArticle_Call {
	_c.Call.Return(run)
	return _c
}

// ListArticleTags provides a mock function with given fields: ctx, slugs
func (_m *MockQuerier) ListArticleTags(ctx context.Context, slugs []uuid.UUID) ([]gen.ListArticleTagsRow, error) {
	ret := _m.Called(ctx, slugs)

	var r0 []gen.ListArticleTagsRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) ([]gen.ListArticleTagsRow, error)); ok {
		return rf(ctx, slugs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) []gen.ListArticleTagsRow); ok {
		r0 = rf(ctx, slugs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.ListArticleTagsRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok {
		r1 = rf(ctx, slugs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListArticleTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListArticleTags'
type MockQuerier_ListArticleTags_Call struct {
	*mock.Call
}

// ListArticleTags is a helper method to define mock.On call
//   - ctx context.Context
//   - slugs []uuid.UUID
func (_e *MockQuerier_Expecter) ListArticleTags(ctx interface{}, slugs interface{}) *MockQuerier_ListArticleTags_Call {
	return &MockQuerier_ListArticleTags_Call{Call: _e.mock.On("ListArticleTags", ctx, slugs)}
}

func (_c *MockQuerier_ListArticleTags_Call) Run(run func(ctx context.Context, slugs []uuid.UUID)) *MockQuerier_ListArticleTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID))
	})
	return _c
}

func (_c *MockQuerier_ListArticleTags_Call) Return(_a0 []gen.ListArticleTagsRow, _a1 error) *MockQuerier_ListArticleTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListArticleTags_Call) RunAndReturn(run func(context.Context, []uuid.UUID) ([]gen.ListArticleTagsRow, error)) *MockQuerier_ListArticleTags_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertArticle provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) UpsertArticle(ctx context.Context, arg gen.UpsertArticleParams) error {
	ret := _m.Called(ctx, arg)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.UpsertArticleParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_UpsertArticle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertArticle'
type MockQuerier_UpsertArticle_Call struct {
	*mock.Call
}

// UpsertArticle is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.UpsertArticleParams
func (_e *MockQuerier_Expecter) UpsertArticle(ctx interface{}, arg interface{}) *MockQuerier_UpsertArticle_Call {
	return &MockQuerier_UpsertArticle_Call{Call: _e.mock.On("UpsertArticle", ctx, arg)}
}

func (_c *MockQuerier_UpsertArticle_Call) Run(run func(ctx context.Context, arg gen.UpsertArticleParams)) *MockQuerier_UpsertArticle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.UpsertArticleParams))
	})
	return _c
}

func (_c *MockQuerier_UpsertArticle_Call) Return(_a0 error) *MockQuerier_UpsertArticle_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_UpsertArticle_Call) RunAndReturn(run func(context.Context, gen.UpsertArticleParams) error) *MockQuerier_UpsertArticle_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQuerier creates a new instance of MockQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQuerier {
	mock := &MockQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
