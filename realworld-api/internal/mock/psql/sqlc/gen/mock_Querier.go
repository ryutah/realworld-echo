// Code generated by mockery v2.32.0. DO NOT EDIT.

package gen

import (
	context "context"

	gen "github.com/ryutah/realworld-echo/realworld-api/infrastructure/psql/sqlc/gen"
	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// MockQuerier is an autogenerated mock type for the Querier type
type MockQuerier struct {
	mock.Mock
}

type MockQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQuerier) EXPECT() *MockQuerier_Expecter {
	return &MockQuerier_Expecter{mock: &_m.Mock}
}

// BulkCreateTagOrDoNothing provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) BulkCreateTagOrDoNothing(ctx context.Context, arg gen.BulkCreateTagOrDoNothingParams) error {
	ret := _m.Called(ctx, arg)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.BulkCreateTagOrDoNothingParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_BulkCreateTagOrDoNothing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkCreateTagOrDoNothing'
type MockQuerier_BulkCreateTagOrDoNothing_Call struct {
	*mock.Call
}

// BulkCreateTagOrDoNothing is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.BulkCreateTagOrDoNothingParams
func (_e *MockQuerier_Expecter) BulkCreateTagOrDoNothing(ctx interface{}, arg interface{}) *MockQuerier_BulkCreateTagOrDoNothing_Call {
	return &MockQuerier_BulkCreateTagOrDoNothing_Call{Call: _e.mock.On("BulkCreateTagOrDoNothing", ctx, arg)}
}

func (_c *MockQuerier_BulkCreateTagOrDoNothing_Call) Run(run func(ctx context.Context, arg gen.BulkCreateTagOrDoNothingParams)) *MockQuerier_BulkCreateTagOrDoNothing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.BulkCreateTagOrDoNothingParams))
	})
	return _c
}

func (_c *MockQuerier_BulkCreateTagOrDoNothing_Call) Return(_a0 error) *MockQuerier_BulkCreateTagOrDoNothing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_BulkCreateTagOrDoNothing_Call) RunAndReturn(run func(context.Context, gen.BulkCreateTagOrDoNothingParams) error) *MockQuerier_BulkCreateTagOrDoNothing_Call {
	_c.Call.Return(run)
	return _c
}

// CountArticleFavorite provides a mock function with given fields: ctx, articleSlug
func (_m *MockQuerier) CountArticleFavorite(ctx context.Context, articleSlug uuid.UUID) (int64, error) {
	ret := _m.Called(ctx, articleSlug)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (int64, error)); ok {
		return rf(ctx, articleSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) int64); ok {
		r0 = rf(ctx, articleSlug)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, articleSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CountArticleFavorite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountArticleFavorite'
type MockQuerier_CountArticleFavorite_Call struct {
	*mock.Call
}

// CountArticleFavorite is a helper method to define mock.On call
//   - ctx context.Context
//   - articleSlug uuid.UUID
func (_e *MockQuerier_Expecter) CountArticleFavorite(ctx interface{}, articleSlug interface{}) *MockQuerier_CountArticleFavorite_Call {
	return &MockQuerier_CountArticleFavorite_Call{Call: _e.mock.On("CountArticleFavorite", ctx, articleSlug)}
}

func (_c *MockQuerier_CountArticleFavorite_Call) Run(run func(ctx context.Context, articleSlug uuid.UUID)) *MockQuerier_CountArticleFavorite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockQuerier_CountArticleFavorite_Call) Return(_a0 int64, _a1 error) *MockQuerier_CountArticleFavorite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CountArticleFavorite_Call) RunAndReturn(run func(context.Context, uuid.UUID) (int64, error)) *MockQuerier_CountArticleFavorite_Call {
	_c.Call.Return(run)
	return _c
}

// CountListArticleFavorite provides a mock function with given fields: ctx, slugs
func (_m *MockQuerier) CountListArticleFavorite(ctx context.Context, slugs []uuid.UUID) ([]gen.CountListArticleFavoriteRow, error) {
	ret := _m.Called(ctx, slugs)

	var r0 []gen.CountListArticleFavoriteRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) ([]gen.CountListArticleFavoriteRow, error)); ok {
		return rf(ctx, slugs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) []gen.CountListArticleFavoriteRow); ok {
		r0 = rf(ctx, slugs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.CountListArticleFavoriteRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok {
		r1 = rf(ctx, slugs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CountListArticleFavorite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountListArticleFavorite'
type MockQuerier_CountListArticleFavorite_Call struct {
	*mock.Call
}

// CountListArticleFavorite is a helper method to define mock.On call
//   - ctx context.Context
//   - slugs []uuid.UUID
func (_e *MockQuerier_Expecter) CountListArticleFavorite(ctx interface{}, slugs interface{}) *MockQuerier_CountListArticleFavorite_Call {
	return &MockQuerier_CountListArticleFavorite_Call{Call: _e.mock.On("CountListArticleFavorite", ctx, slugs)}
}

func (_c *MockQuerier_CountListArticleFavorite_Call) Run(run func(ctx context.Context, slugs []uuid.UUID)) *MockQuerier_CountListArticleFavorite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID))
	})
	return _c
}

func (_c *MockQuerier_CountListArticleFavorite_Call) Return(_a0 []gen.CountListArticleFavoriteRow, _a1 error) *MockQuerier_CountListArticleFavorite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CountListArticleFavorite_Call) RunAndReturn(run func(context.Context, []uuid.UUID) ([]gen.CountListArticleFavoriteRow, error)) *MockQuerier_CountListArticleFavorite_Call {
	_c.Call.Return(run)
	return _c
}

// CreateArticleTag provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) CreateArticleTag(ctx context.Context, arg []gen.CreateArticleTagParams) (int64, error) {
	ret := _m.Called(ctx, arg)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []gen.CreateArticleTagParams) (int64, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []gen.CreateArticleTagParams) int64); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []gen.CreateArticleTagParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateArticleTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateArticleTag'
type MockQuerier_CreateArticleTag_Call struct {
	*mock.Call
}

// CreateArticleTag is a helper method to define mock.On call
//   - ctx context.Context
//   - arg []gen.CreateArticleTagParams
func (_e *MockQuerier_Expecter) CreateArticleTag(ctx interface{}, arg interface{}) *MockQuerier_CreateArticleTag_Call {
	return &MockQuerier_CreateArticleTag_Call{Call: _e.mock.On("CreateArticleTag", ctx, arg)}
}

func (_c *MockQuerier_CreateArticleTag_Call) Run(run func(ctx context.Context, arg []gen.CreateArticleTagParams)) *MockQuerier_CreateArticleTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]gen.CreateArticleTagParams))
	})
	return _c
}

func (_c *MockQuerier_CreateArticleTag_Call) Return(_a0 int64, _a1 error) *MockQuerier_CreateArticleTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateArticleTag_Call) RunAndReturn(run func(context.Context, []gen.CreateArticleTagParams) (int64, error)) *MockQuerier_CreateArticleTag_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrDoNothingTag provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) CreateOrDoNothingTag(ctx context.Context, arg gen.CreateOrDoNothingTagParams) error {
	ret := _m.Called(ctx, arg)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.CreateOrDoNothingTagParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_CreateOrDoNothingTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrDoNothingTag'
type MockQuerier_CreateOrDoNothingTag_Call struct {
	*mock.Call
}

// CreateOrDoNothingTag is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.CreateOrDoNothingTagParams
func (_e *MockQuerier_Expecter) CreateOrDoNothingTag(ctx interface{}, arg interface{}) *MockQuerier_CreateOrDoNothingTag_Call {
	return &MockQuerier_CreateOrDoNothingTag_Call{Call: _e.mock.On("CreateOrDoNothingTag", ctx, arg)}
}

func (_c *MockQuerier_CreateOrDoNothingTag_Call) Run(run func(ctx context.Context, arg gen.CreateOrDoNothingTagParams)) *MockQuerier_CreateOrDoNothingTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.CreateOrDoNothingTagParams))
	})
	return _c
}

func (_c *MockQuerier_CreateOrDoNothingTag_Call) Return(_a0 error) *MockQuerier_CreateOrDoNothingTag_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_CreateOrDoNothingTag_Call) RunAndReturn(run func(context.Context, gen.CreateOrDoNothingTagParams) error) *MockQuerier_CreateOrDoNothingTag_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteArticleTagBySlug provides a mock function with given fields: ctx, articleSlug
func (_m *MockQuerier) DeleteArticleTagBySlug(ctx context.Context, articleSlug uuid.UUID) error {
	ret := _m.Called(ctx, articleSlug)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, articleSlug)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_DeleteArticleTagBySlug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteArticleTagBySlug'
type MockQuerier_DeleteArticleTagBySlug_Call struct {
	*mock.Call
}

// DeleteArticleTagBySlug is a helper method to define mock.On call
//   - ctx context.Context
//   - articleSlug uuid.UUID
func (_e *MockQuerier_Expecter) DeleteArticleTagBySlug(ctx interface{}, articleSlug interface{}) *MockQuerier_DeleteArticleTagBySlug_Call {
	return &MockQuerier_DeleteArticleTagBySlug_Call{Call: _e.mock.On("DeleteArticleTagBySlug", ctx, articleSlug)}
}

func (_c *MockQuerier_DeleteArticleTagBySlug_Call) Run(run func(ctx context.Context, articleSlug uuid.UUID)) *MockQuerier_DeleteArticleTagBySlug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockQuerier_DeleteArticleTagBySlug_Call) Return(_a0 error) *MockQuerier_DeleteArticleTagBySlug_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_DeleteArticleTagBySlug_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockQuerier_DeleteArticleTagBySlug_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsArticleFavorite provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) ExistsArticleFavorite(ctx context.Context, arg gen.ExistsArticleFavoriteParams) (bool, error) {
	ret := _m.Called(ctx, arg)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.ExistsArticleFavoriteParams) (bool, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gen.ExistsArticleFavoriteParams) bool); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, gen.ExistsArticleFavoriteParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ExistsArticleFavorite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsArticleFavorite'
type MockQuerier_ExistsArticleFavorite_Call struct {
	*mock.Call
}

// ExistsArticleFavorite is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.ExistsArticleFavoriteParams
func (_e *MockQuerier_Expecter) ExistsArticleFavorite(ctx interface{}, arg interface{}) *MockQuerier_ExistsArticleFavorite_Call {
	return &MockQuerier_ExistsArticleFavorite_Call{Call: _e.mock.On("ExistsArticleFavorite", ctx, arg)}
}

func (_c *MockQuerier_ExistsArticleFavorite_Call) Run(run func(ctx context.Context, arg gen.ExistsArticleFavoriteParams)) *MockQuerier_ExistsArticleFavorite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.ExistsArticleFavoriteParams))
	})
	return _c
}

func (_c *MockQuerier_ExistsArticleFavorite_Call) Return(_a0 bool, _a1 error) *MockQuerier_ExistsArticleFavorite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ExistsArticleFavorite_Call) RunAndReturn(run func(context.Context, gen.ExistsArticleFavoriteParams) (bool, error)) *MockQuerier_ExistsArticleFavorite_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsFollow provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) ExistsFollow(ctx context.Context, arg gen.ExistsFollowParams) (bool, error) {
	ret := _m.Called(ctx, arg)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.ExistsFollowParams) (bool, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gen.ExistsFollowParams) bool); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, gen.ExistsFollowParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ExistsFollow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsFollow'
type MockQuerier_ExistsFollow_Call struct {
	*mock.Call
}

// ExistsFollow is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.ExistsFollowParams
func (_e *MockQuerier_Expecter) ExistsFollow(ctx interface{}, arg interface{}) *MockQuerier_ExistsFollow_Call {
	return &MockQuerier_ExistsFollow_Call{Call: _e.mock.On("ExistsFollow", ctx, arg)}
}

func (_c *MockQuerier_ExistsFollow_Call) Run(run func(ctx context.Context, arg gen.ExistsFollowParams)) *MockQuerier_ExistsFollow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.ExistsFollowParams))
	})
	return _c
}

func (_c *MockQuerier_ExistsFollow_Call) Return(_a0 bool, _a1 error) *MockQuerier_ExistsFollow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ExistsFollow_Call) RunAndReturn(run func(context.Context, gen.ExistsFollowParams) (bool, error)) *MockQuerier_ExistsFollow_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsListArtileFavorite provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) ExistsListArtileFavorite(ctx context.Context, arg gen.ExistsListArtileFavoriteParams) ([]gen.ExistsListArtileFavoriteRow, error) {
	ret := _m.Called(ctx, arg)

	var r0 []gen.ExistsListArtileFavoriteRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.ExistsListArtileFavoriteParams) ([]gen.ExistsListArtileFavoriteRow, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gen.ExistsListArtileFavoriteParams) []gen.ExistsListArtileFavoriteRow); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.ExistsListArtileFavoriteRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gen.ExistsListArtileFavoriteParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ExistsListArtileFavorite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsListArtileFavorite'
type MockQuerier_ExistsListArtileFavorite_Call struct {
	*mock.Call
}

// ExistsListArtileFavorite is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.ExistsListArtileFavoriteParams
func (_e *MockQuerier_Expecter) ExistsListArtileFavorite(ctx interface{}, arg interface{}) *MockQuerier_ExistsListArtileFavorite_Call {
	return &MockQuerier_ExistsListArtileFavorite_Call{Call: _e.mock.On("ExistsListArtileFavorite", ctx, arg)}
}

func (_c *MockQuerier_ExistsListArtileFavorite_Call) Run(run func(ctx context.Context, arg gen.ExistsListArtileFavoriteParams)) *MockQuerier_ExistsListArtileFavorite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.ExistsListArtileFavoriteParams))
	})
	return _c
}

func (_c *MockQuerier_ExistsListArtileFavorite_Call) Return(_a0 []gen.ExistsListArtileFavoriteRow, _a1 error) *MockQuerier_ExistsListArtileFavorite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ExistsListArtileFavorite_Call) RunAndReturn(run func(context.Context, gen.ExistsListArtileFavoriteParams) ([]gen.ExistsListArtileFavoriteRow, error)) *MockQuerier_ExistsListArtileFavorite_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsListFollow provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) ExistsListFollow(ctx context.Context, arg gen.ExistsListFollowParams) ([]gen.ExistsListFollowRow, error) {
	ret := _m.Called(ctx, arg)

	var r0 []gen.ExistsListFollowRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.ExistsListFollowParams) ([]gen.ExistsListFollowRow, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gen.ExistsListFollowParams) []gen.ExistsListFollowRow); ok {
		r0 = rf(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.ExistsListFollowRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gen.ExistsListFollowParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ExistsListFollow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsListFollow'
type MockQuerier_ExistsListFollow_Call struct {
	*mock.Call
}

// ExistsListFollow is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.ExistsListFollowParams
func (_e *MockQuerier_Expecter) ExistsListFollow(ctx interface{}, arg interface{}) *MockQuerier_ExistsListFollow_Call {
	return &MockQuerier_ExistsListFollow_Call{Call: _e.mock.On("ExistsListFollow", ctx, arg)}
}

func (_c *MockQuerier_ExistsListFollow_Call) Run(run func(ctx context.Context, arg gen.ExistsListFollowParams)) *MockQuerier_ExistsListFollow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.ExistsListFollowParams))
	})
	return _c
}

func (_c *MockQuerier_ExistsListFollow_Call) Return(_a0 []gen.ExistsListFollowRow, _a1 error) *MockQuerier_ExistsListFollow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ExistsListFollow_Call) RunAndReturn(run func(context.Context, gen.ExistsListFollowParams) ([]gen.ExistsListFollowRow, error)) *MockQuerier_ExistsListFollow_Call {
	_c.Call.Return(run)
	return _c
}

// GetArticle provides a mock function with given fields: ctx, slug
func (_m *MockQuerier) GetArticle(ctx context.Context, slug uuid.UUID) (gen.Article, error) {
	ret := _m.Called(ctx, slug)

	var r0 gen.Article
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (gen.Article, error)); ok {
		return rf(ctx, slug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) gen.Article); ok {
		r0 = rf(ctx, slug)
	} else {
		r0 = ret.Get(0).(gen.Article)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, slug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetArticle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetArticle'
type MockQuerier_GetArticle_Call struct {
	*mock.Call
}

// GetArticle is a helper method to define mock.On call
//   - ctx context.Context
//   - slug uuid.UUID
func (_e *MockQuerier_Expecter) GetArticle(ctx interface{}, slug interface{}) *MockQuerier_GetArticle_Call {
	return &MockQuerier_GetArticle_Call{Call: _e.mock.On("GetArticle", ctx, slug)}
}

func (_c *MockQuerier_GetArticle_Call) Run(run func(ctx context.Context, slug uuid.UUID)) *MockQuerier_GetArticle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetArticle_Call) Return(_a0 gen.Article, _a1 error) *MockQuerier_GetArticle_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetArticle_Call) RunAndReturn(run func(context.Context, uuid.UUID) (gen.Article, error)) *MockQuerier_GetArticle_Call {
	_c.Call.Return(run)
	return _c
}

// ListArticleTags provides a mock function with given fields: ctx, slugs
func (_m *MockQuerier) ListArticleTags(ctx context.Context, slugs []uuid.UUID) ([]gen.ListArticleTagsRow, error) {
	ret := _m.Called(ctx, slugs)

	var r0 []gen.ListArticleTagsRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) ([]gen.ListArticleTagsRow, error)); ok {
		return rf(ctx, slugs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) []gen.ListArticleTagsRow); ok {
		r0 = rf(ctx, slugs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gen.ListArticleTagsRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) error); ok {
		r1 = rf(ctx, slugs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListArticleTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListArticleTags'
type MockQuerier_ListArticleTags_Call struct {
	*mock.Call
}

// ListArticleTags is a helper method to define mock.On call
//   - ctx context.Context
//   - slugs []uuid.UUID
func (_e *MockQuerier_Expecter) ListArticleTags(ctx interface{}, slugs interface{}) *MockQuerier_ListArticleTags_Call {
	return &MockQuerier_ListArticleTags_Call{Call: _e.mock.On("ListArticleTags", ctx, slugs)}
}

func (_c *MockQuerier_ListArticleTags_Call) Run(run func(ctx context.Context, slugs []uuid.UUID)) *MockQuerier_ListArticleTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID))
	})
	return _c
}

func (_c *MockQuerier_ListArticleTags_Call) Return(_a0 []gen.ListArticleTagsRow, _a1 error) *MockQuerier_ListArticleTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListArticleTags_Call) RunAndReturn(run func(context.Context, []uuid.UUID) ([]gen.ListArticleTagsRow, error)) *MockQuerier_ListArticleTags_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertArticle provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) UpsertArticle(ctx context.Context, arg gen.UpsertArticleParams) error {
	ret := _m.Called(ctx, arg)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gen.UpsertArticleParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_UpsertArticle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertArticle'
type MockQuerier_UpsertArticle_Call struct {
	*mock.Call
}

// UpsertArticle is a helper method to define mock.On call
//   - ctx context.Context
//   - arg gen.UpsertArticleParams
func (_e *MockQuerier_Expecter) UpsertArticle(ctx interface{}, arg interface{}) *MockQuerier_UpsertArticle_Call {
	return &MockQuerier_UpsertArticle_Call{Call: _e.mock.On("UpsertArticle", ctx, arg)}
}

func (_c *MockQuerier_UpsertArticle_Call) Run(run func(ctx context.Context, arg gen.UpsertArticleParams)) *MockQuerier_UpsertArticle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gen.UpsertArticleParams))
	})
	return _c
}

func (_c *MockQuerier_UpsertArticle_Call) Return(_a0 error) *MockQuerier_UpsertArticle_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_UpsertArticle_Call) RunAndReturn(run func(context.Context, gen.UpsertArticleParams) error) *MockQuerier_UpsertArticle_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQuerier creates a new instance of MockQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQuerier {
	mock := &MockQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
